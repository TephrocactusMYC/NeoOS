//! This module implements the interrupt handling code on x86_64 platforms.
//!
//! # Interrupts
//! Interrupts are signals from a device, such as a keyboard or a hard drive, to the CPU,
//! telling it to immediately stop whatever it is currently doing and do something else.
//! For example, a keyboard controller can send an interrupt when a character key was pressed.
//! Then the OS can display the character on screen immediately, even if the CPU was doing
//! something completely unrelated before, and return to what it was doing afterwards.
//!
//! In x86 protected mode the table is called the Interrupt Descriptor Table (IDT) and can
//! have up to 256 entries
//!
//! # Traps
//! This module *also* implements the trap mechanism, technically, the software generated
//! interrupts. Trap is generated by the kernel when it encounters some exceptions. These
//! exceptions are handled by the so-called trap handlers.
//!
//! # Syscalls
//! In other words, a system call is a request made by a process to the operating system
//! to perform a specific service. A trap, on the other hand, is a type of interrupt that
//! is generated by the operating system in response to exceptional conditions.
//!
//! While system calls, traps, and interrupts both involve the operating system, they serve
//! different purposes and are not interchangeable.

pub mod gdt;
pub mod idt;
pub mod syscall;

use core::arch::asm;

use gdt::init_gdt;
use log::info;

use crate::{
    arch::interrupt::{idt::init_idt, syscall::init_syscalls},
    error::KResult,
};

pub const SYSCALL_REGS: usize = 0x6;

/// A struct that wrapps all the general registers for context switch.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(C)]
pub struct GeneralRegisters {
    pub rax: u64,
    pub rbx: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub rdi: u64,
    pub rsi: u64,
    pub rsp: u64,
    pub rbp: u64,
    pub r8: u64,
    pub r9: u64,
    pub r10: u64,
    pub r11: u64,
    pub r12: u64,
    pub r13: u64,
    pub r14: u64,
    pub r15: u64,
    pub rip: u64,
    pub rflags: u64,
    pub gs: u64,
    pub fs: u64,
}

/// The context for the user processes. It is then stored into TSS.
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(C)]
pub struct UserContext {
    pub regs: GeneralRegisters,
    pub trapno: u64,
    pub errno: u64,
}

impl UserContext {
    /// Returns the type of the system call. This value is stored in RAX.
    pub fn get_syscall_number(&self) -> u64 {
        self.regs.rax
    }

    /// Returns the syscall registers.
    pub fn get_syscall_params(&self) -> [u64; SYSCALL_REGS] {
        [
            self.regs.rdi,
            self.regs.rsi,
            self.regs.rdx,
            self.regs.r10,
            self.regs.r8,
            self.regs.r9,
        ]
    }

    /// Gets the stack pointer.
    pub fn get_rsp(&self) -> u64 {
        self.regs.rsp
    }

    /// Gets the instruction pointer.
    pub fn get_rip(&self) -> u64 {
        self.regs.rip
    }

    /// Sets the next instruction upon saving.
    pub fn set_rip(&mut self, rip: u64) {
        self.regs.rip = rip;
    }

    /// Sets the stack pointer upon saving.
    pub fn set_rsp(&mut self, rsp: u64) {
        self.regs.rsp = rsp;
    }

    /// For sync: each thread has its own areas known as the thread local storage.
    /// This structure is stored in `FSBASE`.
    pub fn tls(&self) -> u64 {
        self.regs.fs
    }
}

/// Initialize the trap handler and the interrupt descriptor table.
pub unsafe fn init_interrupt_all() -> KResult<()> {
    // Step 1: This operation should be atomic, so no other interrupts could happten.
    disable();
    info!("init_interrupt_all(): disabled interrupts.");
    // Step 2: Set up the global descriptor table.
    init_gdt()?;
    info!("init_interrupt_all(): initialized gdt.");
    // Step 3: Set up the interrupt descriptor table.
    init_idt()?;
    info!("init_interrupt_all(): initialized idt.");
    // Step 4: Set up the syscall handlers.
    init_syscalls()?;
    info!("init_interrupt_all(): initialized syscall handlers.");

    Ok(())
}

/// All FLAGS registers contain the condition codes, flag bits that let the results of one machine-language
/// instruction affect another instruction. Since we need to disable the interrupt, the FLAGS registers should
/// be stored onto the stack.
#[inline(always)]
pub unsafe fn disable_and_store() -> usize {
    let mut flags: usize;
    asm!("pushf; pop {flags}; cli", flags = out(reg) flags);
    flags
}

/// Restores the previously disabled interrupt.
#[inline(always)]
pub unsafe fn restore(flags: usize) {
    asm!("push {flags}; popf", flags = in(reg) flags)
}

/// Disables interrupts without getting the RFLAGS.
#[inline(always)]
pub unsafe fn disable() {
    asm!("cli", options(nomem, nostack));
}
